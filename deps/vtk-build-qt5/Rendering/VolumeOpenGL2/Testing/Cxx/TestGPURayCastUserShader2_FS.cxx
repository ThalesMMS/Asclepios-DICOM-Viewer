#include "TestGPURayCastUserShader2_FS.h"

const char *TestGPURayCastUserShader2_FS =
"//VTK::System::Dec\n"
"\n"
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    raycasterfs.glsl\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Inputs\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"/// 3D texture coordinates form vertex shader\n"
"in vec3 ip_textureCoords;\n"
"in vec3 ip_vertexPos;\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Outputs\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"vec4 g_fragColor = vec4(0.0);\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Uniforms, attributes, and globals\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"vec3 g_dataPos;\n"
"vec3 g_dirStep;\n"
"vec4 g_srcColor;\n"
"vec4 g_eyePosObj;\n"
"bool g_exit;\n"
"bool g_skip;\n"
"float g_currentT;\n"
"float g_terminatePointMax;\n"
"vec4 g_scalar;\n"
"\n"
"uniform vec4 in_volume_scale[1];\n"
"uniform vec4 in_volume_bias[1];\n"
"\n"
"out vec4 fragOutput0;\n"
"\n"
"// Volume dataset\n"
"uniform sampler3D in_volume[1];\n"
"uniform int in_noOfComponents;\n"
"uniform int in_independentComponents;\n"
"\n"
"uniform sampler2D in_noiseSampler;\n"
"#ifndef GL_ES\n"
"uniform sampler2D in_depthSampler;\n"
"#endif\n"
"\n"
"// Camera position\n"
"uniform vec3 in_cameraPos;\n"
"\n"
"// view and model matrices\n"
"uniform mat4 in_volumeMatrix[1];\n"
"uniform mat4 in_inverseVolumeMatrix[1];\n"
"uniform mat4 in_projectionMatrix;\n"
"uniform mat4 in_inverseProjectionMatrix;\n"
"uniform mat4 in_modelViewMatrix;\n"
"uniform mat4 in_inverseModelViewMatrix;\n"
"uniform mat4 in_textureDatasetMatrix[1];\n"
"uniform mat4 in_inverseTextureDatasetMatrix[1];\n"
"in mat4 ip_inverseTextureDataAdjusted;\n"
"uniform vec3 in_texMin;\n"
"uniform vec3 in_texMax;\n"
"uniform mat4 in_textureToEye[1];\n"
"\n"
"// Ray step size\n"
"uniform vec3 in_cellStep[1];\n"
"uniform vec2 in_scalarsRange[4];\n"
"uniform vec3 in_cellSpacing[1];\n"
"\n"
"// Sample distance\n"
"uniform float in_sampleDistance;\n"
"\n"
"// Scales\n"
"uniform vec3 in_cellScale;\n"
"uniform vec2 in_windowLowerLeftCorner;\n"
"uniform vec2 in_inverseOriginalWindowSize;\n"
"uniform vec2 in_inverseWindowSize;\n"
"uniform vec3 in_textureExtentsMax;\n"
"uniform vec3 in_textureExtentsMin;\n"
"\n"
"// Material and lighting\n"
"uniform vec3 in_diffuse[4];\n"
"uniform vec3 in_ambient[4];\n"
"uniform vec3 in_specular[4];\n"
"uniform float in_shininess[4];\n"
"\n"
"// Others\n"
"uniform bool in_cellFlag;\n"
"uniform bool in_useJittering;\n"
"vec3 g_rayJitter = vec3(0.0);\n"
"uniform bool in_clampDepthToBackface;\n"
"\n"
"uniform vec2 in_averageIPRange;\n"
"uniform bool in_twoSidedLighting;\n"
"vec3 g_xvec;\n"
"vec3 g_yvec;\n"
"vec3 g_zvec;\n"
"uniform vec3 in_lightAmbientColor[1];\n"
"uniform vec3 in_lightDiffuseColor[1];\n"
"uniform vec3 in_lightSpecularColor[1];\n"
"vec4 g_lightPosObj;\n"
"vec3 g_ldir;\n"
"vec3 g_vdir;\n"
"vec3 g_h;\n"
"bool l_updateDepth;\n"
"vec3 l_opaqueFragPos;\n"
"\n"
"const float g_opacityThreshold = 1.0 - 1.0 / 255.0;\n"
"\n"
"int clippingPlanesSize;\n"
"vec3 objRayDir;\n"
"mat4 textureToObjMat;\n"
"\n"
"//VTK::GradientCache::Dec\n"
"\n"
"uniform sampler2D in_opacityTransferFunc_0[1];\n"
"float computeOpacity(vec4 scalar)\n"
"{\n"
"  return texture2D(in_opacityTransferFunc_0[0], vec2(scalar.w, 0)).r;\n"
"}\n"
"\n"
"// c is short for component\n"
"vec4 computeGradient(int c)\n"
"{\n"
"  // Approximate Nabla(F) derivatives with central differences.\n"
"  vec3 g1; // F_front\n"
"  vec3 g2; // F_back\n"
"  g1.x = texture3D(in_volume[0], vec3(g_dataPos + g_xvec))[c];\n"
"  g1.y = texture3D(in_volume[0], vec3(g_dataPos + g_yvec))[c];\n"
"  g1.z = texture3D(in_volume[0], vec3(g_dataPos + g_zvec))[c];\n"
"  g2.x = texture3D(in_volume[0], vec3(g_dataPos - g_xvec))[c];\n"
"  g2.y = texture3D(in_volume[0], vec3(g_dataPos - g_yvec))[c];\n"
"  g2.z = texture3D(in_volume[0], vec3(g_dataPos - g_zvec))[c];\n"
"\n"
"  // Apply scale and bias to the fetched values.\n"
"  g1 = g1 * in_volume_scale[0][c] + in_volume_bias[0][c];\n"
"  g2 = g2 * in_volume_scale[0][c] + in_volume_bias[0][c];\n"
"\n"
"  // Central differences: (F_front - F_back) / 2h\n"
"  // This version of computeGradient() is only used for lighting\n"
"  // calculations (only direction matters), hence the difference is\n"
"  // not scaled by 2h and a dummy gradient mag is returned (-1.).\n"
"  return vec4((g1 - g2), -1.0);\n"
"}\n"
"\n"
"\n"
"\n"
"uniform sampler2D in_colorTransferFunc_0[1];\n"
"vec3 computeRayDirection()\n"
"{\n"
"  return normalize(ip_vertexPos.xyz - g_eyePosObj.xyz);\n"
"}\n"
"\n"
"//VTK::Picking::Dec\n"
"\n"
"//VTK::RenderToImage::Dec\n"
"\n"
"//VTK::DepthPeeling::Dec\n"
"\n"
"/// We support only 8 clipping planes for now\n"
"/// The first value is the size of the data array for clipping\n"
"/// planes (origin, normal)\n"
"uniform float in_clippingPlanes[49];\n"
"uniform float in_scale;\n"
"uniform float in_bias;\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Helper functions\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"/**\n"
" * Transform window coordinate to NDC.\n"
" */\n"
"vec4 WindowToNDC(const float xCoord, const float yCoord, const float zCoord)\n"
"{\n"
"  vec4 NDCCoord = vec4(0.0, 0.0, 0.0, 1.0);\n"
"\n"
"  NDCCoord.x =\n"
"    (xCoord - in_windowLowerLeftCorner.x) * 2.0 * in_inverseWindowSize.x - 1.0;\n"
"  NDCCoord.y =\n"
"    (yCoord - in_windowLowerLeftCorner.y) * 2.0 * in_inverseWindowSize.y - 1.0;\n"
"  NDCCoord.z = (2.0 * zCoord - (gl_DepthRange.near + gl_DepthRange.far)) /\n"
"    gl_DepthRange.diff;\n"
"\n"
"  return NDCCoord;\n"
"}\n"
"\n"
"/**\n"
" * Transform NDC coordinate to window coordinates.\n"
" */\n"
"vec4 NDCToWindow(const float xNDC, const float yNDC, const float zNDC)\n"
"{\n"
"  vec4 WinCoord = vec4(0.0, 0.0, 0.0, 1.0);\n"
"\n"
"  WinCoord.x =\n"
"    (xNDC + 1.f) / (2.f * in_inverseWindowSize.x) + in_windowLowerLeftCorner.x;\n"
"  WinCoord.y =\n"
"    (yNDC + 1.f) / (2.f * in_inverseWindowSize.y) + in_windowLowerLeftCorner.y;\n"
"  WinCoord.z =\n"
"    (zNDC * gl_DepthRange.diff + (gl_DepthRange.near + gl_DepthRange.far)) /\n"
"    2.f;\n"
"\n"
"  return WinCoord;\n"
"}\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Ray-casting\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"/**\n"
" * Global initialization. This method should only be called once per shader\n"
" * invocation regardless of whether castRay() is called several times (e.g.\n"
" * vtkDualDepthPeelingPass). Any castRay() specific initialization should be\n"
" * placed within that function.\n"
" */\n"
"void initializeRayCast()\n"
"{\n"
"  /// Initialize g_fragColor (output) to 0\n"
"  g_fragColor = vec4(0.0);\n"
"  g_dirStep = vec3(0.0);\n"
"  g_srcColor = vec4(0.0);\n"
"  g_exit = false;\n"
"\n"
"  bool l_adjustTextureExtents = !in_cellFlag;\n"
"  // Get the 3D texture coordinates for lookup into the in_volume dataset\n"
"  g_dataPos = ip_textureCoords.xyz;\n"
"\n"
"  // Eye position in dataset space\n"
"  g_eyePosObj = (in_inverseVolumeMatrix[0] * vec4(in_cameraPos, 1.0));\n"
"  if (g_eyePosObj.w != 0.0)\n"
"  {\n"
"    g_eyePosObj.x /= g_eyePosObj.w;\n"
"    g_eyePosObj.y /= g_eyePosObj.w;\n"
"    g_eyePosObj.z /= g_eyePosObj.w;\n"
"    g_eyePosObj.w = 1.0;\n"
"  }\n"
"\n"
"  // Getting the ray marching direction (in dataset space);\n"
"  vec3 rayDir = computeRayDirection();\n"
"\n"
"  // Multiply the raymarching direction with the step size to get the\n"
"  // sub-step size we need to take at each raymarching step\n"
"  g_dirStep =\n"
"    (ip_inverseTextureDataAdjusted * vec4(rayDir, 0.0)).xyz * in_sampleDistance;\n"
"\n"
"  // 2D Texture fragment coordinates [0,1] from fragment coordinates.\n"
"  // The frame buffer texture has the size of the plain buffer but\n"
"  // we use a fraction of it. The texture coordinate is less than 1 if\n"
"  // the reduction factor is less than 1.\n"
"  // Device coordinates are between -1 and 1. We need texture\n"
"  // coordinates between 0 and 1. The in_noiseSampler and in_depthSampler\n"
"  // buffers have the original size buffer.\n"
"  vec2 fragTexCoord =\n"
"    (gl_FragCoord.xy - in_windowLowerLeftCorner) * in_inverseWindowSize;\n"
"\n"
"  if (in_useJittering)\n"
"  {\n"
"    float jitterValue = texture2D(in_noiseSampler, fragTexCoord).x;\n"
"    g_rayJitter = g_dirStep * jitterValue;\n"
"    g_dataPos += g_rayJitter;\n"
"  }\n"
"  else\n"
"  {\n"
"    g_dataPos += g_dirStep;\n"
"  }\n"
"\n"
"  // Flag to deternmine if voxel should be considered for the rendering\n"
"  g_skip = false;\n"
"  // Light position in dataset space\n"
"  g_lightPosObj = (in_inverseVolumeMatrix[0] * vec4(in_cameraPos, 1.0));\n"
"  if (g_lightPosObj.w != 0.0)\n"
"  {\n"
"    g_lightPosObj.x /= g_lightPosObj.w;\n"
"    g_lightPosObj.y /= g_lightPosObj.w;\n"
"    g_lightPosObj.z /= g_lightPosObj.w;\n"
"    g_lightPosObj.w = 1.0;\n"
"  }\n"
"  g_ldir = normalize(g_lightPosObj.xyz - ip_vertexPos);\n"
"  g_vdir = normalize(g_eyePosObj.xyz - ip_vertexPos);\n"
"  g_h = normalize(g_ldir + g_vdir);\n"
"  g_xvec = vec3(in_cellStep[0].x, 0.0, 0.0);\n"
"  g_yvec = vec3(0.0, in_cellStep[0].y, 0.0);\n"
"  g_zvec = vec3(0.0, 0.0, in_cellStep[0].z);\n"
"\n"
"  l_updateDepth = true;\n"
"  l_opaqueFragPos = vec3(0.0);\n"
"\n"
"  // Flag to indicate if the raymarch loop should terminate\n"
"  bool stop = false;\n"
"\n"
"  g_terminatePointMax = 0.0;\n"
"\n"
"#ifdef GL_ES\n"
"  vec4 l_depthValue = vec4(1.0, 1.0, 1.0, 1.0);\n"
"#else\n"
"  vec4 l_depthValue = texture2D(in_depthSampler, fragTexCoord);\n"
"#endif\n"
"  // Depth test\n"
"  if (gl_FragCoord.z >= l_depthValue.x)\n"
"  {\n"
"    discard;\n"
"  }\n"
"\n"
"  // color buffer or max scalar buffer have a reduced size.\n"
"  fragTexCoord =\n"
"    (gl_FragCoord.xy - in_windowLowerLeftCorner) * in_inverseOriginalWindowSize;\n"
"\n"
"  // Compute max number of iterations it will take before we hit\n"
"  // the termination point\n"
"\n"
"  // Abscissa of the point on the depth buffer along the ray.\n"
"  // point in texture coordinates\n"
"  vec4 terminatePoint =\n"
"    WindowToNDC(gl_FragCoord.x, gl_FragCoord.y, l_depthValue.x);\n"
"\n"
"  // From normalized device coordinates to eye coordinates.\n"
"  // in_projectionMatrix is inversed because of way VT\n"
"  // From eye coordinates to texture coordinates\n"
"  terminatePoint = ip_inverseTextureDataAdjusted * in_inverseVolumeMatrix[0] *\n"
"    in_inverseModelViewMatrix * in_inverseProjectionMatrix * terminatePoint;\n"
"  terminatePoint /= terminatePoint.w;\n"
"\n"
"  g_terminatePointMax =\n"
"    length(terminatePoint.xyz - g_dataPos.xyz) / length(g_dirStep);\n"
"  g_currentT = 0.0;\n"
"\n"
"  //VTK::RenderToImage::Init\n"
"\n"
"  //VTK::DepthPass::Init\n"
"}\n"
"\n"
"/**\n"
" * March along the ray direction sampling the volume texture.  This function\n"
" * takes a start and end point as arguments but it is up to the specific render\n"
" * pass implementation to use these values (e.g. vtkDualDepthPeelingPass). The\n"
" * mapper does not use these values by default, instead it uses the number of\n"
" * steps defined by g_terminatePointMax.\n"
" */\n"
"vec4 castRay(const float zStart, const float zEnd)\n"
"{\n"
"  //VTK::DepthPeeling::Ray::Init\n"
"\n"
"  //VTK::DepthPeeling::Ray::PathCheck\n"
"\n"
"  /// For all samples along the ray\n"
"  while (!g_exit)\n"
"  {\n"
"\n"
"    g_skip = false;\n"
"    if (!g_skip && g_srcColor.a > 0.0 && l_updateDepth)\n"
"    {\n"
"      l_opaqueFragPos = g_dataPos;\n"
"      l_updateDepth = false;\n"
"    }\n"
"\n"
"    //VTK::PreComputeGradients::Impl\n"
"\n"
"    if (!g_skip)\n"
"    {\n"
"      vec4 scalar = texture3D(in_volume[0], g_dataPos);\n"
"      scalar.r = scalar.r * in_volume_scale[0].r + in_volume_bias[0].r;\n"
"      scalar = vec4(scalar.r, scalar.r, scalar.r, scalar.r);\n"
"      g_scalar = scalar;\n"
"      g_srcColor = vec4(0.0);\n"
"      g_srcColor.a = computeOpacity(scalar);\n"
"    }\n"
"\n"
"    //VTK::RenderToImage::Impl\n"
"\n"
"    //VTK::DepthPass::Impl\n"
"\n"
"    /// Advance ray\n"
"    g_dataPos += g_dirStep;\n"
"\n"
"    if (any(greaterThan(g_dataPos, in_texMax)) ||\n"
"      any(lessThan(g_dataPos, in_texMin)))\n"
"    {\n"
"      break;\n"
"    }\n"
"\n"
"    // Early ray termination\n"
"    // if the currently composited colour alpha is already fully saturated\n"
"    // we terminated the loop or if we have hit an obstacle in the\n"
"    // direction of they ray (using depth buffer) we terminate as well.\n"
"    if ((g_fragColor.a > g_opacityThreshold) ||\n"
"      g_currentT >= g_terminatePointMax)\n"
"    {\n"
"      break;\n"
"    }\n"
"    ++g_currentT;\n"
"  }\n"
"\n"
"  return g_fragColor;\n"
"}\n"
"\n"
"/**\n"
" * Finalize specific modes and set output data.\n"
" */\n"
"void finalizeRayCast()\n"
"{\n"
"\n"
"  //VTK::Picking::Exit\n"
"\n"
"  //VTK::RenderToImage::Exit\n"
"  if (l_opaqueFragPos == vec3(0.0))\n"
"  {\n"
"    gl_FragData[0] = vec4(0.0);\n"
"  }\n"
"  else\n"
"  {\n"
"    gl_FragData[0] =\n"
"      texture2D(in_colorTransferFunc_0[0], vec2(l_opaqueFragPos.z, 0.0)).xyzw;\n"
"  }\n"
"\n"
"  //VTK::DepthPass::Exit\n"
"}\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Main\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"void main()\n"
"{\n"
"  //VTK::CallWorker::Impl\n"
"}\n"
"";
